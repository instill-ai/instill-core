## Provide a name in place of vdp for `app:` labels
##
nameOverride: ""

## Override the deployment namespace
##
namespaceOverride: ""

## Provide a name to substitute for the full names of resources
##
fullnameOverride: ""

expose:
  # Set how to expose the api-gateway service. Set the type as "ingress", "clusterIP", "nodePort" or "loadBalancer"
  # and fill the information in the corresponding section
  type: ingress
  tls:
    # Enable TLS or not.
    enabled: true
    # The source of the tls certificate. Set as "auto", "secret"
    # or "none" and fill the information in the corresponding section
    # 1) auto: generate the tls certificate automatically
    # 2) secret: read the tls certificate from the specified secret.
    # The tls certificate can be generated manually or by cert manager
    # 3) none: configure no tls certificate for the ingress. If the default
    # tls certificate is configured in the ingress controller, choose this option
    certSource: auto
    auto:
      # The common name used to generate the certificate, it's necessary
      # when the type isn't "ingress"
      commonName: ""
    secret:
      # The name of secret which contains keys named:
      # "tls.crt" - the certificate
      # "tls.key" - the private key
      secretName: ""
  ingress:
    hosts:
      gateway: api.instill.tech
      console: console.instill.tech
    # set to the type of ingress controller if it has specific requirements.
    # leave as `default` for most ingress controllers.
    # set to `gce` if using the GCE ingress controller
    controller: default
    ## Allow .Capabilities.KubeVersion.Version to be overridden while creating ingress
    kubeVersionOverride: ""
    className: ""
    annotations: {}
  clusterIP:
    # The name of ClusterIP service
    name:
    # Annotations on the ClusterIP service
    annotations: {}
    ports:
      # The service port api-gateway listens on
      gateway:
      # The service port api-gateway stats listens on
      stats:
      # The service port api-gateway metrics listens on
      metrics:
  nodePort:
    # The name of NodePort service
    name:
    ports:
      gateway:
        # The service port api-gateway listens on
        port:
        # The node port api-gateway listens on
        nodePort: 30000
      stats:
        # The service port api-gateway stats listens
        port:
        # The node port api-gateway stats listens on
        nodePort: 30001
      metrics:
        # The service port api-gateway metrics listens on
        port:
        # The node port api-gateway metrics listens on
        nodePort: 30002
  loadBalancer:
    # The name of LoadBalancer service
    name:
    # Set the IP if the LoadBalancer supports assigning IP
    IP: ""
    ports:
      # The service port api-gateway listens on
      gateway:
      # The service port api-gateway stats listens on
      stats:
      # The service port api-gateway metrics listens on
      metrics:
    annotations: {}
    sourceRanges: []

# The external URL for VDP core service. It is used to
# populate the API endpoints showed on Console
#
# Format: protocol://domain[:port]. Usually:
# 1) if "expose.type" is "ingress", the "domain" should be
# the value of "expose.ingress.hosts.gateway"
# 2) if "expose.type" is "clusterIP", the "domain" should be
# the value of "expose.clusterIP.name"
# 3) if "expose.type" is "nodePort", the "domain" should be
# the IP address of Kubernetes node
#
# If VDP is deployed behind the proxy, set it as the URL of proxy
externalURL: https://api.instill.tech

# The internal TLS used for VDP components secure communicating. In order to enable https
# in each components tls cert files need to provided in advance.
internalTLS:
  # If internal TLS enabled
  enabled: false
  # There are three ways to provide tls
  # 1) "auto" will generate cert automatically
  # 2) "manual" need provide cert file manually in following value
  # 3) "secret" internal certificates from secret
  certSource: "auto"
  # The content of trust ca, only available when `certSource` is "manual"
  trustCa: ""
  # api-gateway related cert configuration
  apigateway:
    # secret name for api-gateway's tls certs, only available when `certSource` is "secret"
    secretName: ""
    # Content of api-gateway's TLS cert file, only available when `certSource` is "manual"
    crt: ""
    # Content of api-gateway's TLS key file, only available when `certSource` is "manual"
    key: ""
  # pipeline-backend related cert configuration
  pipeline:
    # secret name for pipeline-backend's tls certs, only available when `certSource` is "secret"
    secretName: ""
    # Content of pipeline-backend's TLS key file, only available when `certSource` is "manual"
    crt: ""
    # Content of pipeline-backend's TLS key file, only available when `certSource` is "manual"
    key: ""
  # connector-backend related cert configuration
  connector:
    # secret name for connector-backend's tls certs, only available when `certSource` is "secret"
    secretName: ""
    # Content of connector-backend's TLS key file, only available when `certSource` is "manual"
    crt: ""
    # Content of connector-backend's TLS key file, only available when `certSource` is "manual"
    key: ""
  # model-backend related cert configuration
  model:
    # secret name for model-backend's tls certs, only available when `certSource` is "secret"
    secretName: ""
    # Content of model-backend's TLS key file, only available when `certSource` is "manual"
    crt: ""
    # Content of model-backend's TLS key file, only available when `certSource` is "manual"
    key: ""
  # mgmt-backend related cert configuration
  mgmt:
    # secret name for mgmt-backend's tls certs, only available when `certSource` is "secret"
    secretName: ""
    # Content of mgmt-backend's TLS key file, only available when `certSource` is "manual"
    crt: ""
    # Content of mgmt-backend's TLS key file, only available when `certSource` is "manual"
    key: ""
  # console related cert configuration
  console:
    # secret name for console's tls certs, only available when `certSource` is "secret"
    secretName: ""
    # Content of console's TLS key file, only available when `certSource` is "manual"
    crt: ""
    # Content of console's TLS key file, only available when `certSource` is "manual"
    key: ""

# The persistence is enabled by default and a default StorageClass
# is needed in the k8s cluster to provision volumes dynamically.
# Specify another StorageClass in the "storageClass" or set "existingClaim"
# if you already have existing persistent volumes to use
persistence:
  enabled: true
  # Setting it to "keep" to avoid removing PVCs during a helm delete
  # operation. Leaving it empty will delete PVCs after the chart deleted
  # (this does not apply for PVCs that are created for internal database
  # and redis components, i.e. they are never deleted automatically)
  resourcePolicy: "keep"
  persistentVolumeClaim:
    vdp:
      # Use the existing PVC which must be created manually before bound,
      # and specify the "subPath" if the PVC is shared with other components
      existingClaim: ""
      # Specify the "storageClass" used to provision the volume. Or the default
      # StorageClass will be used (the default).
      # Set it to "-" to disable dynamic provisioning
      storageClass: ""
      subPath: ""
      accessMode: ReadWriteOnce
      size: 5Gi
      annotations: {}
    airbyte:
      existingClaim: ""
      storageClass: ""
      subPath: ""
      accessMode: ReadWriteOnce
      size: 5Gi
      annotations: {}
    # If external database is used, the following settings for database will
    # be ignored
    database:
      existingClaim: ""
      storageClass: ""
      subPath: ""
      accessMode: ReadWriteMany
      size: 1Gi
      annotations: {}
    # If external Redis is used, the following settings for Redis will
    # be ignored
    redis:
      existingClaim: ""
      storageClass: ""
      subPath: ""
      accessMode: ReadWriteOnce
      size: 1Gi
      annotations: {}

imagePullPolicy: IfNotPresent

# Use this set to assign a list of default pullSecrets
imagePullSecrets:

# The update strategy for deployments with persistent volumes: "RollingUpdate" or "Recreate"
# Set it as "Recreate" when "RWM" for volumes isn't supported
updateStrategy:
  type: RollingUpdate

# Logging level: debug, info, warning, error or fatal
logLevel: debug

# The maximum data payload to VDP cluster (MB)
maxDataSizeMB: 12

# Disable usage collection
disableUsage: false

apigateway:
  # -- The image of api-gateway
  image:
    repository: instill/api-gateway
    tag: latest
    pullPolicy: IfNotPresent
  # -- Set the service account to be used, default if left empty
  serviceAccountName: ""
  # -- Mount the service account token
  automountServiceAccountToken: false
  # -- The number of replica for api-gateway
  replicaCount: 1
  # -- Add extra env variables
  extraEnv: []
  # -- Mount external volume
  # For example, mount a secret containing Certificate root CA to verify database
  # TLS connection.
  extraVolumes: []
  # - name: my-volume
  #   secret:
  #     secretName: my-secret
  extraVolumeMounts: []
  # - name: my-volume
  #   mountPath: /etc/secrets/my-secret
  #   readOnly: true
  # -- Add extra init containers
  extraInitContainers: []
  # extraInitContainers:
  #  - name: ...
  #    image: ...
  # -- Add extra sidecar containers
  sidecarContainers: {}
  # -- Additional deployment annotations
  podAnnotations: {}
  # -- Additional service annotations
  serviceAnnotations: {}

  resources: {}

  autoscaling:
    enabled: false
    minReplicas:
    maxReplicas:
    targetCPUUtilizationPercentage:
    targetMemoryUtilizationPercentage:

  nodeSelector: {}

  tolerations: []

  affinity: {}

  podDisruptionBudget:
    enabled: false
    spec:
      minAvailable:
      maxUnavailable:

pipeline:
  # -- The image of pipeline-backend
  image:
    repository: instill/pipeline-backend
    tag: latest
    pullPolicy: IfNotPresent
  # -- Set the service account to be used, default if left empty
  serviceAccountName: ""
  # -- Mount the service account token
  automountServiceAccountToken: false
  # -- The number of replica for pipeline-backend
  replicaCount: 1
  # -- Add extra env variables
  extraEnv: []
  # -- Mount external volumes
  # For example, mount a secret containing Certificate root CA to verify database
  # TLS connection.
  extraVolumes: []
  # - name: my-volume
  #   secret:
  #     secretName: my-secret
  extraVolumeMounts: []
  # - name: my-volume
  #   mountPath: /etc/secrets/my-secret
  #   readOnly: true
  # -- Add extra init containers
  extraInitContainers: []
  # extraInitContainers:
  #  - name: ...
  #    image: ...
  # -- Add extra sidecar containers
  sidecarContainers: {}
  # -- Additional deployment annotations
  podAnnotations: {}
  # -- Additional service annotations
  serviceAnnotations: {}

  resources: {}

  autoscaling:
    enabled: false
    minReplicas:
    maxReplicas:
    targetCPUUtilizationPercentage:
    targetMemoryUtilizationPercentage:

  nodeSelector: {}

  tolerations: []

  affinity: {}

  podDisruptionBudget:
    enabled: false
    spec:
      minAvailable:
      maxUnavailable:

mgmt:
  # -- The image of pipeline-backend
  image:
    repository: instill/mgmt-backend
    tag: 0.2.9-alpha
    pullPolicy: IfNotPresent
  # -- Set the service account to be used, default if left empty
  serviceAccountName: ""
  # -- Mount the service account token
  automountServiceAccountToken: false
  # -- The number of replica for pipeline-backend
  replicaCount: 1
  # -- Add extra env variables
  extraEnv: []
  # -- Mount external volumes
  # For example, mount a secret containing Certificate root CA to verify database
  # TLS connection.
  extraVolumes: []
  # - name: my-volume
  #   secret:
  #     secretName: my-secret
  extraVolumeMounts: []
  # - name: my-volume
  #   mountPath: /etc/secrets/my-secret
  #   readOnly: true
  # -- Add extra init containers
  extraInitContainers: []
  # extraInitContainers:
  #  - name: ...
  #    image: ...
  # -- Add extra sidecar containers
  sidecarContainers: {}
  # -- Additional deployment annotations
  podAnnotations: {}
  # -- Additional service annotations
  serviceAnnotations: {}

  resources: {}

  autoscaling:
    enabled: false
    minReplicas:
    maxReplicas:
    targetCPUUtilizationPercentage:
    targetMemoryUtilizationPercentage:

  nodeSelector: {}

  tolerations: []

  affinity: {}

  podDisruptionBudget:
    enabled: false
    spec:
      minAvailable:
      maxUnavailable:

usageServer:
  tlsenabled: true
  host: usage.instill.tech
  port: 443

database:
  # -- If external database is used, set "type" to "external"
  # and fill the connection informations in "external" section
  type: internal
  internal:
    # -- Set the service account to be used, default if left empty
    serviceAccountName: ""
    # -- Mount the service account token
    automountServiceAccountToken: false
    image:
      repository: postgres
      tag: 15-alpine
    # -- The initial superuser password for internal database
    password: "password"
    # -- The size limit for Shared memory, pgSQL use it for shared_buffer
    # More details see:
    # https://github.com/goharbor/harbor/issues/15034
    shmSizeLimit: 512Mi
    resources: {}
    #  requests:
    #    memory: 256Mi
    #    cpu: 100m
    # -- The timeout used in livenessProbe; 1 to 5 seconds
    livenessProbe:
      timeoutSeconds: 1
    # -- The timeout used in readinessProbe; 1 to 5 seconds
    readinessProbe:
      timeoutSeconds: 1
    # -- Additional deployment annotations
    podAnnotations: {}
    # -- Additional service annotations
    serviceAnnotations: {}
    nodeSelector: {}
    tolerations: []
    affinity: {}
    initContainer:
      migrator:
        resources: {}
      #  requests:
      #    memory: 128Mi
      #    cpu: 100m
      permissions:
        resources: {}
      #  requests:
      #    memory: 128Mi
      #    cpu: 100m
  external:
    host:
    port:
    username:
    password:
    # -- If existing secret is used, the key must be "password"
    existingSecret: ""
    # -- SSL mode
    # "disable" - No SSL
    # "require" - Always SSL (skip verification)
    # "verify-ca" - Always SSL (verify that the certificate presented by the
    # server was signed by a trusted CA)
    # "verify-full" - Always SSL (verify that the certification presented by the
    # server was signed by a trusted CA and the server host name matches the one
    # in the certificate)
    sslmode: "disable"
  # -- The maximum number of connections in the idle connection pool per pod (core+exporter).
  # If it <=0, no idle connections are retained.
  maxIdleConns: 100
  # -- The maximum number of open connections to the database per pod (core+exporter).
  # If it <= 0, then there is no limit on the number of open connections.
  # Note: the default number of connections is 1024 for postgre of harbor.
  maxOpenConns: 900
  # -- The maximum amount of time in minutes a connection may be reused.
  # Expired connections may be closed lazily before reuse.
  # If it <= 0, connections are not closed due to a connection's age.
  maxConnLifeTime: 30m

redis:
  # -- If external Redis is used, set "type" to "external"
  # and fill the connection informations in "external" section
  type: internal
  internal:
    # -- Set the service account to be used, default if left empty
    serviceAccountName: ""
    # -- Mount the service account token
    automountServiceAccountToken: false
    image:
      repository: redis
      tag: 7.0-alpine3.16
    resources: {}
    #  requests:
    #    memory: 256Mi
    #    cpu: 100m
    ## -- The priority class to run the pod as
    priorityClassName:
    # -- Additional deployment annotations
    podAnnotations: {}
    # -- Additional service annotations
    serviceAnnotations: {}
    nodeSelector: {}
    tolerations: []
    affinity: {}
    initContainer:
      migrator:
        resources: {}
      #  requests:
      #    memory: 128Mi
      #    cpu: 100m
      permissions:
        resources: {}
      #  requests:
      #    memory: 128Mi
      #    cpu: 100m
  external:
    # -- Support redis, redis+sentinel
    # addr for redis: <host_redis>:<port_redis>
    # addr for redis+sentinel: <host_sentinel1>:<port_sentinel1>,<host_sentinel2>:<port_sentinel2>,<host_sentinel3>:<port_sentinel3>
    addr:
    # -- The name of the set of Redis instances to monitor, it must be set to support redis+sentinel
    sentinelMasterSet: ""
    password: ""
    # -- If using existingSecret, the key must be REDIS_PASSWORD
    existingSecret: ""

#######################
# Temporal
#######################
temporal:
  clientoptions:
    hostport: temporal:7233
